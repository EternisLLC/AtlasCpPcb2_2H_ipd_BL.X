#include    <xc.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <stdbool.h>
#include    <string.h>
#include    <libpic30.h>
#include    "alwaysCP_210728.h"
#include    "functionUART24.h"
#include    "FunctionRS485_K.h"
#include    "terminal.h"
#include    "InterruptTimer24.h"
#include    "crc8.h"
#include    "DriverAt45.h"
#include    "functionCP.h"
#include "DriverMFRC522cp.h"
UINT16 CounterErrRxPacket = 0;  //  счетчик пакетов принятых с ошибками  
char LineLcd[128]={0,0,0,0,0,0,0};     //входной буфер для терминала
char LineRs[256];     //входной буфер для терминала
#define MaxCommands  30                    //размер массива команд (количество команд)
unsigned int cnt,cnt2;                           //временный счётчик
//имёна команд - нужно для внутренней идентефикации команды (для обработки в case)
typedef enum COMMAND_LIST_U4 {
    Unk_Nown,        //ЙЪН. 27.11.19
    PAGE_CURRENT,
    CHECK_PSW,
    PAGE_NEW,
    CHANGE_PSW,
    TIME_VRF,
    TIME_CHANGE,
    NEXT_DIR,
    ADD_BU,
    DEL_BU,
    KID_READ,
    KID_SAVE,
    INC,
    DEC,
    PLAY,
    AUTO_DIR,
    RESET_DIR,
    START_DIR,
    READ_ARHIV_LCD,
    READ_ARHIV_USB,
    UPDATE,
    BRIGHT,         // ЙЪН. 24.03.22
    CHANGE_MODE_RS, // ЙЪН. 07.04.22
}CommandListU4;

//текстовый образец комманды, который поступает в терминал
//в терминале, через пробел нужно указать параметры этой команды
//массив команд терминала и их имён
const CommandType   CommandsU4[MaxCommands]=
{//"Команда",       "Имя команды"
    {   "PageC",        PAGE_CURRENT    },
    {   "CheckPsw",     CHECK_PSW       },
    {   "NewPg",        PAGE_NEW        },
    {   "ChangePsw",    CHANGE_PSW      },
    {   "TimeVrf",      TIME_VRF        },
    {   "TimeSet",      TIME_CHANGE     },
    {   "NextDir",      NEXT_DIR        },
    {   "AddBu",        ADD_BU          },
    {   "DelBu",        DEL_BU          },
    {   "Kid",          KID_READ        },
    {   "SaveKid",      KID_SAVE        },
    {   "Inc",          INC             },
    {   "Dec",          DEC             },
    {   "Play",         PLAY            },
    {   "Auto",         AUTO_DIR        },
    {   "Rst",          RESET_DIR       },
    {   "StartMP",      START_DIR       },
    {   "Read",         READ_ARHIV_LCD  },
    {   "ReadAll",      READ_ARHIV_USB  },
    {   "Update",       UPDATE          },
    {   "Dim",          BRIGHT          },  // ЙЪН. 24.03.22
    {   "ChangeModeRs", CHANGE_MODE_RS  },  // ЙЪН. 07.04.22
};
/*
void InitTerminal (void){
    InitUart1(38400);
}*/
/*----------------------------------------------*/
/* получение символов из входного буфера        */
/*----------------------------------------------*/

int xgetsU4 (		/* 0:нет данных для обработки, 1:строка доступна */
	char* buff,	/* указатель на буфер */
	int len		/* Длинна буфера */
)
{
static int c, i;

	for (;;) {
        if (!uart4_testRx()) {
            return 0;
        }
		c = uart4_getc();				/* Чтение одного байта из входного потока */
		if (!c) return 0;               /* Конец потока? */
		if (c == '\r') break;           /* Конец строки? */
		if (c >= ' ' && i < len - 1) {	/*Видимые символы */
			buff[i++] = c;
		}
	}
	buff[i] = 0;	/* Добавляем в конец строки \0 */
    i = 0;
	return 1;
}

/*----------------------------------------------*/
/* Получение числа из строки                    */
/*----------------------------------------------*/
/*	"123 -5   0x3ff 0b1111 0377  w "
	    ^                           1st call returns 123 and next ptr
	       ^                        2nd call returns -5 and next ptr
                   ^                3rd call returns 1023 and next ptr
                          ^         4th call returns 15 and next ptr
                               ^    5th call returns 255 and next ptr
                                  ^ 6th call fails and returns 0
*/

int xatoi (			/* 0:Failed, 1:Successful */
	char **str,		/* Pointer to pointer to the string */
	long *res		/* Pointer to the valiable to store the value */
)
{
	unsigned long val;
	unsigned char c, r, s = 0;


	*res = 0;

	while ((c = **str) == ' ') (*str)++;	/* Skip leading spaces */

	if (c == '-') {		/* negative? */
		s = 1;
		c = *(++(*str));
	}

	if (c == '0') {
		c = *(++(*str));
		switch (c) {
		case 'x':		/* hexdecimal */
			r = 16; c = *(++(*str));
			break;
		case 'b':		/* binary */
			r = 2; c = *(++(*str));
			break;
		default:
			if (c <= ' ') return 1;	/* single zero */
			if (c < '0' || c > '9') return 0;	/* invalid char */
			r = 8;		/* octal */
		}
	} else {
		if (c < '0' || c > '9') return 0;	/* EOL or invalid char */
		r = 10;			/* decimal */
	}

	val = 0;
	while (c > ' ') {
		if (c >= 'a') c -= 0x20;
		c -= '0';
		if (c >= 17) {
			c -= 7;
			if (c <= 9) return 0;	/* invalid char */
		}
		if (c >= r) return 0;		/* invalid char for current radix */
		val = val * r + c;
		c = *(++(*str));
	}
	if (s) val = 0 - val;			/* apply sign if needed */

	*res = val;
	return 1;
}
//******************************************************************************
//**************************** M A I N *****************************************
//******************************************************************************
UINT8   TempDirectRs = 0;
UINT8   TempCommandRs = 0;
UINT8   TempNumberKid = 0;
char   LcdBufferData[64];
static UINT16 COUNTER_COMMAND;
static UINT8  redy; // ЙЪН. 01.04.22
// ЙЪН. 29.03.22 #include    "iButton.h"
void TerminalLcd (void){
unsigned int CounterCommands=0;                                                 //счётчик списка команд
unsigned int CounterParam=0;                                                    //счётчик параметров
unsigned int    CounterData;
unsigned int NameCommand=0;                                                     //имя команды
char *ptr;
unsigned char dir;
long param[10]={0,0,0,0,0,0,0,0,0,0};
if (!xgetsU4(LineLcd, sizeof LineLcd)){
    return;                                          //если строка не готова, то выходим
}
ptr = LineLcd;                                                                     //присваиваем указатель на полученную строку временной переменной
//------------------ распаковка принятой строки --------------------------------
while (CounterCommands<MaxCommands){                                            //перебираем список комманд
   // printf("Перебор команд:%d\n",CounterCommands);
    if (!strncmp(ptr,CommandsU4[CounterCommands].Command,strlen(CommandsU4[CounterCommands].Command))){     //если команда есть в списке,то
        ptr=strchr(ptr,' ');                                                    //смещаем до первого пробела
        while(xatoi(&ptr,&param[CounterParam])){                                //перебираем параметры команды
            CounterParam++;                                                     //увеличиваем счётчика параметров
           // printf("Перебор параметров:%d\n",CounterParam);
        }                              
        break;
    }
    CounterCommands++;                                                          //увеличиваем счётчик списка команд
}//конкц while (i<MaxCommands)
NameCommand = CommandsU4[CounterCommands].Name;                                     //присвоение имени найденой команды
//============
COUNTER_COMMAND ++;
/*ПФМБДЛБ*/if(LcdFlag.Debug){
    if(NameCommand > 0 && NameCommand < 24){
        xprintf("%u Command %u -> %s ",COUNTER_COMMAND,NameCommand,CommandsU4[CounterCommands].Command );
    }else{
        xprintf("%u ERROR %u \r",COUNTER_COMMAND,NameCommand);
    //    WaitingScreen = 255;
        LcdFlag.WaitNewScreen1 = 0;
        return;
    }
    CounterData = 0;
    if(CounterParam){
        while(CounterData < CounterParam){
            xprintf("%lu ",param[CounterData]);
            CounterData ++;
        }
    }
    xprintf("\r");
}
//xprintf("wi - %u\r",RxFifoU4.wi);
//xprintf("ri - %u\r",RxFifoU4.ri);
//xprintf("ct - %u\r",RxFifoU4.ct);
//===============
//printf("Команда:"); printf(Commands[CounterCommands].Command);//printf("\n");
//printf(" Длина:%d Параметров:%d\n",strlen(Commands[CounterCommands].Command),CounterParam); 
//printf("Массив параметров: %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld \n",param[0],param[1],param[2],param[3],param[4],param[5],param[6],param[7],param[8],param[9]);

//******************************************************************************
//*******             Обработка принятых команд       **************************
//******* входные параметры: 
//******* NameCommand - имя команды (задаётся в  COMMANDLIST используется в case)
//******* CounterParam - количество параметров в команде
//******* long param[x] - массив параметров команды, где param[0]-это первый параметр
//******* 
//******************************************************************************
    switch (NameCommand) {
        UINT8 index;
//------------------------------------------------------------------------------       
//--- Если команда есть в списке, но для неё ещё не написан обработчик ---------
//------------------------------------------------------------------------------       
        default :
//            xprintf("LineLcd -> ");
//            xprintf("%s",LineLcd);
////            for(index = 0; index < 128; index ++){
////                xprintf("%c",LineLcd[index]);
////            }
//            xprintf("\r");
//            xprintf("RxFifoU4 -> ");
//            for(index = 0; index < 128; index ++){
//                xprintf("%c",RxFifoU4.buff[index]);
//            }
//            xprintf("\r");
//            xprintf("wi - %u\r",RxFifoU4.wi);
//            xprintf("ri - %u\r",RxFifoU4.ri);
//            xprintf("ct - %u\r",RxFifoU4.ct);
//            xprintf("TxFifoU4 -> ");
//            for(index = 0; index < 128; index ++){
//                xprintf("%c",TxFifoU4.buff[index]);
//            }
//            xprintf("\r");
//            xprintf("wi - %u\r",TxFifoU4.wi);
//            xprintf("ri - %u\r",TxFifoU4.ri);
//            xprintf("ct - %u\r",TxFifoU4.ct);
//            Nop();
            break;
        case    PAGE_CURRENT :
            if(!param[0] && CurrentScreen == 255){
                SaveEvent(100);
            }
            if(!param[0]){ // РЕТЕИПД ОБ 0 УФТБОЙГХ
                printf("t0.txt=\"ver%02lu.%02lu.%02lu\"яяя",VerD,VerM,VerY);
            }
//----------------
            if(!CurrentScreen && param[0] == 10){
                redy = 0;
                // РТПЧЕТСЕН ЕБ ОБМЙЮЙЙ ЪБТЕЗЙУФТЙТПЧБООЩИ вх
                for(index = 1; (index < 11 && !redy); index ++){
                    if(StatusBU[index].SerialNumber){
                       redy = 1; 
                    }
                }
            }
//---------------            
            CurrentScreen = param[0];
            if(CurrentScreen == WaitingScreen){ // ЧЩРПМОЕО РЕТЕИПД ОБ ОХЦОХА УФТБОЙГХ?
                LcdFlag.WaitNewScreen1 = 0;      // УОЙНБЕН ЖМБЗ ПЦЙДБОЙС РЕТЕИПДБ
                CounterWaitingNewScreen = 0;
                WaitingScreen = 255;
                /*ПФМБДЛБ*/ if(LcdFlag.Debug)xprintf("jump ok %lu ms\r",Counter1ms);
                LcdFlag.NewPage = 1;
                switch(CurrentScreen){
                    case 5:
                        Nop();
                        ModeRs = ReadCharFromAt45(2047,250); // 16.09.22
                        SelectModeRs485(ModeRs);
                        switch(ControlFlagCP.CurrentModeRs){
                            case 0:
                                break;
                            case 1:
                                printf("page5.b1.pic=92яяя");
                                break;
                            case 2: case 3:
                                printf("page5.b1.pic=91яяя");
                            break;
                        }
                        break;
                    case 7:
                        PrintDirectionNumber(CurrentScreen);
                        StatusBU[SelectedDirection].SerialNumber = ReadLongFromAT45(2047,(SelectedDirection * 4));
                        if(StatusBU[SelectedDirection].SerialNumber==0x0){
                            printf("page7.show.txt=\"0\"яяя");
                            printf("page7.b10.txt=\"дпвбчйфш\"яяя");
                        }else{
                            printf("page7.show.txt=\"%lu\"яяя", StatusBU[SelectedDirection].SerialNumber);
                            printf("page7.b10.txt=\"хдбмйфш\"яяя");
                        }
                        break;
                    case 10:
                        if(!redy){
                            WaitingScreen = 0;              // РЕТЕНЕООПК WaitingScreen РТЙУЧБЕЧБЕН 0 ОПНЕТ УФТБОЙГЩ ОБ ЛПФПТХА ЧЩРПМОСЕФУС РЕТЕИПД
                            LcdFlag.WaitNewScreen1 = 1;      // ЧЩУФБЧМСЕН ЖМБЗ ОПЧПЗП РЕТЕИПДБ
                            sprintf(LcdBufferData,"page %uяяя",WaitingScreen);
                            LcdFlag.NewPage = 1;
                            CurrentScreen = 0;
                            printf("%s",LcdBufferData); /*ПФМБДЛБ*/if(LcdFlag.Debug)xprintf("%s 1a\r",LcdBufferData);
                            /*ПФМБДЛБ*/if(LcdFlag.Debug)xprintf("Device no redy\r");
                        }else{
                            /*ПФМБДЛБ*/if(LcdFlag.Debug)xprintf("Device redy\r");
                        }
                        break;
                    case 11:
                        CounterCheckBU = 0;
                        break;
                    case 12:
                        break;
                    case 13:
                        break;
                    case 14:
                        break;
                    case 15:
                       TempSound  = SOUND;
                        TempLedError = LED_ERROR;
                        TempLedFire = LED_FIRE;
                        TempLedStart = LED_START;
                        TempLedAuto = LED_AUTO; 
                        break;
                    case 18: case 19:
                        NewEventLcdFlag.RedyDataBos = 1;
                        break;
                    case 20:
                        NewEventLcdFlag.RedyDataBos = 1;
                        LcdFlag.Yes = 1;
                        break;
                        
                }
            }else{
                /*ПФМБДЛБ*/if(LcdFlag.Debug)xprintf("error jump\r");
            }
            break;
        case    CHECK_PSW:
            if(param[0] == AccessPassword){
                WaitingScreen = 2;
                LcdFlag.WaitNewScreen1 = 1;
                LcdFlag.NewPage = 0;
            }else{
//                printf("page 0яяя"); // РЕТЕИПД ОБ ОБЮБМШОЩК ЬЛТБО
                WaitingScreen = 0;
                LcdFlag.WaitNewScreen1 = 1;
                LcdFlag.NewPage = 0;
            }
            break;
            
//++++++++++++=            
        case PAGE_NEW:
            
            if(CounterParam < 2){
                if(LcdFlag.Debug)/*ПФМБДЛБ*/xprintf("ERR coomand\r");
                break;
            }
            if(LcdFlag.WaitNewScreen1){
                if(LcdFlag.Debug)/*ПФМБДЛБ*/xprintf("ERROR jump\r");
// ПЫЙВЛБ РЕТЕИПДБ
                break;
            }
            Bright = 80;    // ЙЪН. 24.03.22
            if(WaitingScreen == 255){
                WaitingScreen = (UINT8)param[0]; // РЕТЕНЕООПК WaitingScreen РТЙУЧБЕЧБЕН ОПНЕТ УФТБОЙГЩ ОБ ЛПФПТХА ЧЩРПМОСЕФУС РЕТЕИПД
                LcdFlag.WaitNewScreen1 = 1;      // ЧЩУФБЧМСЕН ЖМБЗ ОПЧПЗП РЕТЕИПДБ
                if(param[1] != 255){
                    SelectedDirection = (UINT8) param[1];    // РЕТЕНЕООПК SelectDirection  РТЙУЧБЕЧБЕН ОПНЕТ ОБРТБЧМЕОЙС У ЛПФПТЩН УПВЙТБЕНУС ТБВПФБФШ
                    CounterCheckBU = 0;
                    Interval._1min = 1;
                }
                if(WaitingScreen == 111){
                    if(ClassAlgoritm[SelectedDirection] < 11){
                        WaitingScreen = 11;
                    }else{
                        WaitingScreen = 16;
                    }
                }
                if(WaitingScreen == 19){
                    if(CurrentScreen !=20)GroupNumber = (UINT8) param[2];
                }
                if(WaitingScreen == 20){
                    DeviceNumber = (UINT16) param[2];
                }
                if(CurrentScreen == 15){
                    SOUND = TempSound;
                    LED_ERROR = TempLedError;
                    LED_FIRE = TempLedFire;
                    LED_START = TempLedStart;
                    LED_AUTO = TempLedAuto;
                }
                PreviousScreen = CurrentScreen;     // УПИТБОСЕН ОПНЕТ ЬЛТБОБ У ЛПФПТПЗП ЧЩРПМОСЕФУС РЕТЕИПД
            }
            break;
        case    CHANGE_PSW:
            if(CurrentScreen == 6){
                OldAccessPassword = AccessPassword;;
                AccessPassword = param[0];
                SaveAccessPassword(AccessPassword);
                SaveEvent(105); // УПВЩФЙЕ ЙЪНЕОЕОЙЕ РБТПМС
                sprintf(LcdBufferData,"page6.show.bco=%uяяя", GREEN);
                printf("%s",LcdBufferData); //xprintf("%s\r",LcdBufferData);
                
            }
            break;
        case    TIME_VRF:
            CurrentTime.Year = (unsigned int)param[0];
            CurrentTime.Month = (unsigned char)param[1];
            CurrentTime.Day = (unsigned char)param[2];
            CurrentTime.Hour = (unsigned char)param[3];
            CurrentTime.Minute = (unsigned char)param[4];
            CurrentTime.Second = (unsigned char)param[5];
            break;
        case    TIME_CHANGE:
            if(CurrentScreen == 3){
                CurrentTime.Year = (unsigned int)param[0];
                CurrentTime.Month = (unsigned char)param[1];
                CurrentTime.Day = (unsigned char)param[2];
                CurrentTime.Hour = (unsigned char)param[3];
                CurrentTime.Minute = (unsigned char)param[4];
                CurrentTime.Second = (unsigned char)param[5];
                SaveEvent(101);
                printf("t20.pco=%uяяя",GREEN);
                CounterDelaySec = 1;
                while (CounterDelaySec);
                printf("t20.pco=%uяяя", BLACK);
            }
            break;
        case NEXT_DIR:
            SelectedDirection ++;
            if(SelectedDirection > 10){
                SelectedDirection = 1;
            }
            
            StatusBU[SelectedDirection].SerialNumber = ReadLongFromAT45(2047,(SelectedDirection * 4));
            PrintDirectionNumber(CurrentScreen);
            if(StatusBU[SelectedDirection].SerialNumber==0x0){
                printf("page7.show.txt=\"0\"яяя");
                printf("page7.b10.txt=\"дпвбчйфш\"яяя");
            }else{
                printf("page7.show.txt=\"%lu\"яяя", StatusBU[SelectedDirection].SerialNumber);
                printf("page7.b10.txt=\"хдбмйфш\"яяя");
            }
            break;
        case    ADD_BU:
            dir = (unsigned char)param[0];
            if (StatusBU[dir].SerialNumber) {
                // РПРЩФЛБ ЪБРЙУЙ Ч ЪБОСФХА СЮЕКЛХ
                printf("page7.show.bco=%uяяя", YELOW);
                CounterDelaySec = 1;
                while (CounterDelaySec);
                printf("page7.show.bco=%uяяя", WHITE);
                return;
            }
            if (!StatusBU[dir].SerialNumber) { // ЕУМЙ СЮЕКЛБ ОЕ ЪБОСФБ
                UINT8 ii;
                for (ii = 1; ii < 11; ii++) {
                    // РТПЧЕТЛБ ОБ УПЧРБДЕОЙЕ УЕТЙКОЩИ ОПНЕТПЧ
                    if (param[1] == StatusBU[ii].SerialNumber) {
                        printf("page7.show.bco=%uяяя", YELOW);
                        CounterDelaySec = 1;
                        while (CounterDelaySec);
                        printf("page7.show.txt=\"%lu\"яяя", StatusBU[dir].SerialNumber);
                        printf("page7.show.bco=%uяяя", WHITE);
                        LcdFlag.NewSn = 0;
                        return;
                    }
                }
                // ЪБРЙУШ ОПЧПЗП УЕТЙКОПЗП ОПНЕТБ
                printf("page7.show.bco=%uяяя", GREEN);
                CounterDelaySec = 1;
                StatusBU[dir].SerialNumber = param[1];
                SaveSerialNumberBU(StatusBU[dir].SerialNumber, (dir * 4));
                while (CounterDelaySec);
                SaveEvent(102);
                printf("page7.show.txt=\"%lu\"яяя", StatusBU[dir].SerialNumber);
                printf("page7.show.bco=%uяяя", WHITE);
                printf("page7.b10.txt=\"хдбмйфш\"яяя");
            }
            Nop();
            break;
        case    DEL_BU:
            // ХДБМЕОЙЕ ЪБРЙУБООПЗП УЕТЙКОПЗП ОПНЕТБ
            dir = (unsigned char)param[0];
            printf("page7.show.bco=%uяяя", GREEN);
            CounterDelaySec = 2;
            TempSerialNumberBUR = StatusBU[dir].SerialNumber;
            StatusBU[dir].SerialNumber = 0;
            SaveEvent(103);
            SaveSerialNumberBU(StatusBU[dir].SerialNumber, (dir * 4));
            while (CounterDelaySec);
            printf("page7.show.txt=\"%lu\"яяя", StatusBU[dir].SerialNumber);
            printf("page7.show.bco=%uяяя", WHITE);
            printf("page7.b10.txt=\"дпвбчйфш\"яяя");
            Nop();
            break;
        case    KID_READ:   // ЙЪН. 01.04.22
            NumberKID = (UINT8)param[0];
            ReadRegisteredKid(NumberKID); // ЮФЕОЙЕ УПИТБОЕООПЗП ЛМАЮБ Ч РЕТЕНЕООЩЕ
            printf("page4.t4.txt=\"%lu\"яяя", SerialNumberKid[NumberKID].SerialKid); // ЙЪН. 20.06.22
            printf("page4.t14.txt=\"\"яяя");
            printf("page4.t13.pic=27яяя");
            if(SerialNumberKid[NumberKID].SerialKid){
                printf("page4.b0.txt=\"хдбмйфш\"яяя");
            }else{
                printf("page4.b0.txt=\"ъбрйубфш\"яяя");
            }
            break;
        case    KID_SAVE:   // ЙЪН. 01.04.22
            NumberKID = (UINT8)param[0];
            TempNumberKid = (UINT8)param[0];
            
            if(FlagMFRC522._newCart){ // ЕУМЙ ХДБЮОП РТПЮЙФБО ЛМАЮ
                if(SerialNumberKid[0].SerialKid == SerialNumberKid[1].SerialKid || 
                    SerialNumberKid[0].SerialKid == SerialNumberKid[2].SerialKid ||
                    SerialNumberKid[0].SerialKid == SerialNumberKid[3].SerialKid ||
                    SerialNumberKid[0].SerialKid == SerialNumberKid[4].SerialKid ||
                    SerialNumberKid[0].SerialKid == SerialNumberKid[5].SerialKid ||
                    SerialNumberKid[0].SerialKid == SerialNumberKid[6].SerialKid ||
                    SerialNumberKid[0].SerialKid == SerialNumberKid[7].SerialKid ||
                    SerialNumberKid[0].SerialKid == SerialNumberKid[8].SerialKid ||
                    SerialNumberKid[0].SerialKid == SerialNumberKid[9].SerialKid ||
                    SerialNumberKid[0].SerialKid == SerialNumberKid[10].SerialKid){
                    printf("page4.t14.txt=\"ХЦЕ ЕУФШ\"яяя");
                    printf("page4.t13.pic=26яяя");
                }else{
                    SavingRegisteredKid(NumberKID); // УПИТБОСЕН Ч РБНСФЙ ОПЧЩК ЛМАЮ
                    ReadRegisteredKid(NumberKID); // ЛПОФТПМШОПЕ ЮФЕОЙЕ УПИТБОЕООПЗП ЛМАЮБ Ч РЕТЕНЕООЩЕ
                    if(SerialNumberKid[NumberKID].SerialKid == SerialNumberKid[0].SerialKid){
                        printf("page4.t4.txt=\"%lu\"яяя", SerialNumberKid[NumberKID].SerialKid); // ЙЪН. 20.06.22
                        printf("page4.t14.txt=\"ЪБРЙУБО\"яяя");
                        printf("page4.t13.pic=27яяя");
                        printf("page4.b0.txt=\"хдбмйфш\"яяя");
                        SaveEvent(106);
                    }else{
                        printf("page4.t14.txt=\"ОЕ ЪБРЙУБО\"яяя");
                        printf("pfge4.t13.pic=26яяя");
                    }
                }
                FlagMFRC522._newCart = 0;
            }else{
                if(!SerialNumberKid[NumberKID].SerialKid){
                    printf("page4.t14.txt=\"ОЕФ ЛМАЮБ\"яяя");
                    printf("t13.pic=26яяя");
                }else{
                    SerialNumberKid[NumberKID].SerialKid = 0;
                    SavingRegisteredKid(NumberKID); // УПИТБОСЕН Ч РБНСФЙ ОПЧЩК ЛМАЮ
                    printf("page4.t14.txt=\"ЛМАЮ ХДБМЕО\"яяя");
                    printf("page4.b0.txt=\"ъбрйубфш\"яяя");
                }
            }
            break;
        case PLAY:
            LcdFlag.Select = param[0];
            if(LcdFlag.Select){
                LcdFlag.Play = 1;
                LcdFlag.HandDoun = 0;
                LcdFlag.HandUp = 0;
            }else{
                LcdFlag.Play = 0;
            }
            break;
        case INC:
            LcdFlag.Select = param[0];
            LcdFlag.HandDoun = 0;
            LcdFlag.HandUp = 1;
            break;
        case DEC:
            LcdFlag.Select = param[0];
            LcdFlag.HandUp = 0;
            LcdFlag.HandDoun = 1;
            break;
        case AUTO_DIR:

// ЙЪН. 29.03.22             TempNumberKid = SearchIbutton();
            TempNumberKid = SearchNumberKid(); // ЙЪН. 01.04.22
            if(TempNumberKid == 0 || TempNumberKid > 10) break;
            TempDirectRs = SelectedDirection; // УПИТБОСЕН ОПНЕТ ОБРТБЧМЕОЙС
            printf("t0.txt=\"пцйдбойе теблгйй\"яяя");
// ЙЪН. 02.09.22
            switch(StatusBU[SelectedDirection].StatusAuto.StatusAutoByte & 0b11000000){
                case AUTO:
                    if(LcdFlag.Debug)/*ПФМБДЛБ*/xprintf("Com 5 auto lcd\r");
                    TempCommandRs = 5;
                    SaveEvent(15); // УПВЩФЙЕ ОБЦБФБ ЛОПЛБ ХРТБЧМЕОЙС БЧФПНБФЙЛПК ОБ лр 
                    break;
                case MANUAL:
                    // ЖПТНЙТХЕН ЛПНБОДХ БЧФПНБФЙЛБ ЪБВМПЛЙТПЧБОБ
                    if(LcdFlag.Debug)/*ПФМБДЛБ*/xprintf("Com 5 manual lcd\r");
                    TempCommandRs = 5;
                    SaveEvent(15); // УПВЩФЙЕ ОБЦБФБ ЛОПЛБ ХРТБЧМЕОЙС БЧФПНБФЙЛПК ОБ лр
                    break;
                case LOCK:
                    // ЖПТНЙТХЕН ЛПНБОДХ БЧФПНБФЙЛБ ТБЪВМПЛЙТПЧБОБ
                    if(LcdFlag.Debug)/*ПФМБДЛБ*/xprintf("Com 4 lcd\r");
                    TempCommandRs = 4;
                    SaveEvent(14); // УПВЩФЙЕ ОБЦБФБ ЛОПЛБ ХРТБЧМЕОЙС БЧФПНБФЙЛПК ОБ лр 
                    break;
            }
            break;
        case RESET_DIR:

// ЙЪН. 29.03.22             TempNumberKid = SearchIbutton();
            TempNumberKid = SearchNumberKid(); // ЙЪН. 01.04.22
            if(TempNumberKid == 0 || TempNumberKid > 10) break;
            printf("t0.txt=\"пцйдбойе теблгйй\"яяя");
            TempDirectRs = SelectedDirection; // УПИТБОСЕН ОПНЕТ ОБРТБЧМЕОЙС
            TempCommandRs = 6;  // ЛПНБОДБ УВТПУ
            break;
        case START_DIR:
            if((StatusBU[SelectedDirection].StatusAuto.StatusAutoByte & 0b11000000) == LOCK)break;// ЙЪН. 02.09.22
// ЙЪН. 29.03.22             TempNumberKid = SearchIbutton();
            TempNumberKid = SearchNumberKid(); // ЙЪН. 01.04.22
            if(TempNumberKid == 0 || TempNumberKid > 10) break;
            printf("t0.txt=\"пцйдбойе теблгйй\"яяя");
            TempDirectRs = SelectedDirection; // УПИТБОСЕН ОПНЕТ ОБРТБЧМЕОЙС
            TempCommandRs = 7;  // ЛПНБОДБ УФБТФ РП ОБРТБЧМЕОЙА
            break;
        case READ_ARHIV_LCD:
            LcdFlag.Select = param[0];
            if(LcdFlag.Select){
                LcdFlag.Play = 1;
                LcdFlag.HandDoun = 0;
                LcdFlag.HandUp = 0;
            }else{
                LcdFlag.Play = 0;
            }
            break;
        case READ_ARHIV_USB:
            LcdFlag.Select = param[0];
            break;
        case UPDATE:
            if(CurrentScreen == 5){
                //__asm__ volatile ("reset");
                asm ("RESET");
            }
            break;
        case BRIGHT:   // ЙЪН. 24.03.22
// ХУФБОПЧЛБ СТЛПУФЙ РТЙ ЛБУБОЙЙ ДЙУРМЕС            
//            if(Bright != 80){
//                Bright = 80;
//                printf("dim=%uяяя",Bright);
//            }
//            CounterLcdSleep = 30;
            break;
// ЙЪН. 07.04.22++++++++++++++++++++++++
        case CHANGE_MODE_RS: 
            if(ControlFlagCP.CurrentModeRs == 1){
                SelectModeRs485(2);
                if(ControlFlagCP.CurrentModeRs == 2){
                    printf("page5.b1.pic=91яяя");
                }
            }else{
                SelectModeRs485(1);
                if(ControlFlagCP.CurrentModeRs == 1){
                    printf("page5.b1.pic=92яяя");
                }
            }
            SaveModeRs485((unsigned char) ControlFlagCP.CurrentModeRs);
            break;
        
//+++++++++++++++++++++++++++++++++            
    } 
}
//имёна команд - нужно для внутренней идентефикации команды (для обработки в case)
typedef enum COMMAND_LIST_U2 {
    UnkNown,        //ЙЪН. 19.11.19
    FromBU,    //
    FromBOS,
    For_M0,
    FromPC
}CommandListU2;
const CommandType   CommandsU2[MaxCommands]=
{//"Команда",       "Имя команды"
    { "/",          FromBU },
    { "<",          FromBOS },
    { "#",          FromPC  }
};
int xgetsU2 (		/* 0:нет данных для обработки, 1:строка доступна */
	char* buff,	/* указатель на буфер */
	int len		/* Длинна буфера */
)
{
static int c, i;

	for (;;) {
        if (!RS485_testRx()) {
            return 0;
        }
		c = RS485_getc();				/* Чтение одного байта из входного потока */
		if (!c) return 0;               /* Конец потока? */
		if (c == '\r'){
            break;           /* Конец строки? */
        } 
		if (c >= ' ' && i < len - 1) {	/*Видимые символы */
			buff[i++] = c;
		}
	}
	buff[i] = 0;	/* Добавляем в конец строки \0 */
    i = 0;
	return 1;
}
int xatoiRs (			/* 0:Failed, 1:Successful */
	char **str,		/* Pointer to pointer to the string */
	long *res		/* Pointer to the valiable to store the value */
)
{
	unsigned long val;
	unsigned char c, r, s = 0;
	*res = 0;
	while ((c = **str) == ' ') (*str)++;	/* Skip leading spaces */
	if (c == '-') {		/* negative? */
		s = 1;
		c = *(++(*str));
	}
	if (c == '0') {
		c = *(++(*str));
		switch (c) {
		case 'x':		/* hexdecimal */
			r = 16; c = *(++(*str));
			break;
		case 'b':		/* binary */
			r = 2; c = *(++(*str));
			break;
		default:
			if (c <= ' ') return 1;	/* single zero */
			if (c < '0' || c > '9') return 0;	/* invalid char */
			r = 8;		/* octal */
		}
	} else {
		if (c < '0' || c > '9') return 0;	/* EOL or invalid char */
		r = 10;			/* decimal */
	}
	val = 0;
	while (c > ' ') {
		if (c >= 'a') c -= 0x20;
		c -= '0';
		if (c >= 17) {
			c -= 7;
			if (c <= 9) return 0;	/* invalid char */
		}
		if (c >= r) return 0;		/* invalid char for current radix */
		val = val * r + c;
		c = *(++(*str));
	}
	if (s) val = 0 - val;			/* apply sign if needed */
	*res = val;
	return 1;
}
UINT8 digits(long n) {
    UINT8 i = 0;
    UINT32 nn; 
    if (n < 0){
        nn = -n;
    }else{
        nn = n;
    }
    while (nn > 0) {
        nn = nn/10;
        i ++;
    }
    if(!i) i = 1;
    return i;
}
void ClrLine(char*Array,unsigned int Length ){
    unsigned int i;
    for(i = 0; i < Length; i++){
        *Array = 0;
        Array++;
    }
}
#define DIRECTION_R     paramRs[0]
#define ADRR_SOURCE_R   paramRs[1]
#define COMAND_R        paramRs[2]
//******************************************************************************
//**************************** M A I N *****************************************
//******************************************************************************
void TerminalRs (void){
unsigned int CounterCommandsRs=0;                                                 //счётчик списка команд
unsigned int CounterParamRs=0;                                                    //счётчик параметров
unsigned int NameCommandRs=0;                                                     //имя команды
unsigned int    tempInt;
char *ptrs;
long paramRs[20]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
static UINT8   LengthRxData;
unsigned char crcRx;
unsigned char crcRxLength;
unsigned int    tempLine;
    tempLine = strlen(LineRs);
    if(tempLine > 128){
        ClrLine(LineRs,256);
    }
    if (!xgetsU2(LineRs, sizeof LineRs)){
        return;             //ЧЩИПДЙН ЕУМЙ УФТПЛБ ОЕ ЗПФПЧБ 
    }
    ptrs = LineRs; //РТЙУЧБЕЧБЕН хЛБЪБФЕМШ ОБ РПМХЮЕООХА УФТПЛХ ЧТЕНЕООПК РЕТЕНЕООПК
//------------------ тБУРБЛПЧЛБ РТЙОСФПК УФТПЛЙ --------------------------------
    while (CounterCommandsRs<MaxCommands){                                            //РЕТЕВЙТБЕН УРЙПЛ ЛПНБОД
        if (!strncmp(ptrs,CommandsU2[CounterCommandsRs].Command,strlen(CommandsU2[CounterCommandsRs].Command))){     //ЕУМЙ ЛПНБОДБ ЕУФШ Ч УРЙУЛЕ
            ptrs=strchr(ptrs,' ');                                                    //УНЕЭБЕН ДП РЕТЧПЗП РТПВЕМБ
            while(xatoiRs(&ptrs,&paramRs[CounterParamRs])){                           //РЕТЕВЙТБЕН РБТБНЕФТЩ ЛПНБОДЩ
                CounterParamRs++;                                                     //ХЧЕМЙЮЙЧБЕН УЮЕФЮЙЛ РБТБНЕФТПЧ
            }                              
            break;
        }
        CounterCommandsRs++;                                                          //ХЧЕМЙЮЙЧБЕН УЮЕФЮЙЛ УРЙУЛБ ЛПНБОД
    }//ЛПОЕГ while (i<MaxCommands)
//===========
    LengthRxData = strlen(LineRs);                                      //ЧЩЮЙУМСЕН ДМЙОХ УФТПЛЙ
    crcRxLength = digits(paramRs[CounterParamRs - 1]);                  // ЧЩЮЙУМСЕН ТБЪТСДОПУФШ РПУМЕДОЕЗП РБТБНЕФТБ
    crcRx = Crc8((unsigned char*)LineRs,(LengthRxData - crcRxLength));  // ЧЩЮЙУМСЕН лу
    if(crcRx != (unsigned char)(paramRs[CounterParamRs - 1])){          //рТПЧЕТСЕН лу
        CounterErrRxPacket ++;
        if(CounterErrRxPacket > 10){
            ClrLine(LineRs,256);
        }
        return;
    }
    CounterErrRxPacket = 0; 
//+++++++++++++++
    NameCommandRs=CommandsU2[CounterCommandsRs].Name;                                     //РТЙУЧПЕОЙЕ ЙНЕОЙ ОБКДЕООПК ЛПНБОДЕ
// ПВТБВПФЮЙЛ ЛПНБОД
    switch (NameCommandRs) {
        default :
            if(LcdFlag.Debug)/*ПФМБДЛБ*/xprintf("Err Rs\r");//ЙЪН. 19.11.19
            break;
        case FromBU:
            if(CounterParamRs == 5){// РТЙОСФП УППВЭЕОЙЕ П ЛПМЙЮЕУФЧЕ РПДЛМАЮЕООЩИ ВПУ
                if(RequestedSerial != paramRs[1]){
                    return;
                }
                NumberOfResponses[ControlFlagCP.CurrentModeRs] ++; // ЙЪН. 05.04.22
                StatusBU[0].Direct = paramRs[0];
                StatusBU[0].SerialNumber = paramRs[1];
                StatusBU[0].QuantityBos = paramRs[2];
                ClassAlgoritm[DirectControl] = paramRs[3];
                CounterDelayRs = 2;
                WaitData = 1;
            }else{
                if(CounterParamRs > 13){
                    if(RequestedSerial != paramRs[7]){
                        return;
                    }
                    NumberOfResponses[ControlFlagCP.CurrentModeRs] ++; // ЙЪН. 05.04.22
                    StatusBU[0].Direct = paramRs[6];
                    StatusBU[0].SerialNumber = paramRs[7];
                    StatusBU[0].IdNet = paramRs[8];
                    StatusBU[0].Situation = paramRs[9];
                    if(StatusBU[0].Situation != StatusBU[DirectControl].Situation){
                        NewEventLcdFlag.NewSituation = 1;
                    }
                    StatusBU[0].FlagErrRoom.ErrByte = (UINT8)paramRs[10];
                    if(StatusBU[0].FlagErrRoom.ErrByte != StatusBU[DirectControl].FlagErrRoom.ErrByte){
                        NewEventLcdFlag.NewStaus = 1;
                    }
// ЙЪН. 25.03.22                    
                    if(StatusBU[0].SerialNumber > 2111000){ 
                        paramRs[10] = paramRs[10] >> 8;
                        FildFlagsPcb2[0].ByteFlagRoom_Pcb2 = (UINT8)paramRs[10];
// ЙЪН. 12.09.22 УВПУ ЧУЕЗП ОБРТБЧМЕОЙС РТЙ РПМХЮЕОЙЙ ЛПНБОДЩ ПФ вхт
                        if(FildFlagsPcb2[0].Reset){
                            TempCommandRs = 6;  // ЛПНБОДБ УВТПУ
                            FildFlagsPcb2[0].Reset = 0;
                        }
                        if(FildFlagsPcb2[0].ByteFlagRoom_Pcb2 != FildFlagsPcb2[DirectControl].ByteFlagRoom_Pcb2){
                            NewEventLcdFlag.NewStaus = 1;
                        }
                    }
//====================                    
                    StatusBU[0].StatusAuto.StatusAutoByte = paramRs[11];
                    if(StatusBU[0].StatusAuto.StatusAutoByte != StatusBU[DirectControl].StatusAuto.StatusAutoByte){
                        NewEventLcdFlag.NewAuto = 1;
                    }
                    tempInt = (unsigned int)paramRs[12];
                    StatusBU[0].FlagControlDirect.ControlByte = (UINT8)tempInt;
                    if(StatusBU[0].FlagControlDirect.ControlByte != StatusBU[DirectControl].FlagControlDirect.ControlByte){
                        NewEventLcdFlag.NewOut = 1;
                    }
                    FildFlagsPcb2[0].classIP = (tempInt >> 12);
                    // ЙЪН. 09.04.2020 ЖЙЛУБГЙС ФТЕЧПЗЙ ПФ впу Ч 
                    // ОХМЕЧПН ЬМЕНЕОФЕ НБУУЙЧБ УФТХЛФХТ StatusBos[0].AlarmByte
                    CounterDelayStart[0] = paramRs[13];
                    if(CurrentScreen == 10)StatusBos[0].AlarmByte = 0;
                    CounterDelayRs = 2;
                    WaitData = 1;
                }else{
                    return; // УППВЭЕОЙЕ ОЕ УППФЧЕФУЧХЕФ ЪБРТПУХ
                }
            }
            break; 
        case FromBOS:
            StatusBos[paramRs[0]].ShortAddres = paramRs[0];
            StatusBos[paramRs[0]].SerialNumber = paramRs[2];
            StatusBos[paramRs[0]].AlarmByte = paramRs[3];
            if(StatusBos[paramRs[0]].AlarmByte){
                CounterAlarmBos ++; //
                switch(StatusBos[paramRs[0]].AlarmByte & 0x03){
                    case 1:
                        CounterAttentionDevice ++;
                        break;
                    case 2:
                        CounterFireDevice ++;
                        break;
                    case 3:
                        CounterStartDevice ++;
                        break;
                }
            }
            // ЙЪН 09.04.2020 УПИТБОСЕН ФЕЛХЭХА ПВУФБОПЧЛХ ПФ впу
            if(StatusBos[0].AlarmByte < StatusBos[paramRs[0]].AlarmByte){
                StatusBos[0].AlarmByte = StatusBos[paramRs[0]].AlarmByte;
                LcdFlag.NewData = 1;
            }
            StatusBos[paramRs[0]].StatusByte = paramRs[4];
            if(StatusBos[paramRs[0]].StatusByte) CounterErrBos ++;
            StatusBos[paramRs[0]].TemperaturaSensor[0] = paramRs[5];
            StatusBos[paramRs[0]].TemperaturaSensor[1] = paramRs[6];
            break;
    }//ЛПОЕГ switch (NameCommand) 
}


